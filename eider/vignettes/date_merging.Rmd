---
title: "Date Merging"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Date Merging}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(eider)
```

Formatting

```{r}
library(knitr)
library(kableExtra)
library(tidyverse)
kbl <- function(x) {
  x <- head(x, 10)
  x %>%
    knitr::kable(format = "html",
                 table.attr = 'data-quarto-disable-processing="true"') %>%
    kableExtra::kable_styling(bootstrap_options = "striped",
                              full_width = FALSE)
}
```

## 1. Read in data
Here we are reading in data about patients stays where they can have multiple episodes in one stay

This is the original dataframe
```{r}
smr04_data_filepath <- eider_example("random_smr04_data.csv")
initial_table <- read_data(smr04_data_filepath)[[1]]
initial_table %>% kbl()
```

Each row is an episode. Multiple episodes make up a stay. The `cis_marker` field can be used to group episodes from one id into a stay. I.e. all rows for a (`id`, `cis_marker`) tuple correspond to a single stay. `episode_within_cis` tells us the order of the episodes within a stay.

```{r}
p3_only <- initial_table[initial_table$id == 3, ]
p3_only %>% kbl()
```

Using patient with ID of 3 as an example - the data contains details of 4 episodes (with `CIS_MARKERS` of 23, 24, 25, and 26). For the stay with `CIS_MARKER` 23, there were three episodes, all started on 17th May 2015 and ended on the same date. For the stays with `CIS_MARKER` 24, and 25, there was only one episode, and for the stay with `CIS_MARKER` 26 there were 3 episodes, the first episode had an admission date of 21st April 2015, and a discharge date of the 22nd April. The second episode had an admission date of the 22nd April and a discharge date of the same day, and the third episode had an admission date of the 22nd but a discharge date of the 24th. This stay for patient 3 spanned the 21st to 24th of April.

With episodic data is could be necessary to filter on dates. If in the example of patient with ID 14 the cut-off-date was set as 1st August, then the first episode in their stay would be omitted, and potentially the second episode would be assumed to be the first. 

## 2. Describe the pre-processing

The way `eider` has approached this, is to allow users to pre-process their data, to merge episodes into stays. In this case by specifying that they can select the earliest admission date for each stay and the latest discharge date for each stay and replace each episode with the stay-related span.

The key features outlined here are: The `grouping_column`, the `preprocess$on` as well as the `preprocess$retain_min` and `preprocess$retain_max`. We can put these in a mini specification and call the preprocessing function directly

Here we define a mini specification with only the important features
```{r}
minispec <- list()
minispec$grouping_column <- "id"
minispec$preprocess$on <- "cis_marker"
minispec$preprocess$retain_min <- "admission_date"
minispec$preprocess$retain_max <- "discharge_date"
```

This mini-specification will use the `cis_marker` column to identify which episodes belong with a given patient stay, and then the minimum `admission_date` and maximum `discharge_date` are replaced in the initial data
Then we can run it with the example SMR04 data


```{r}
processed_table <- preprocess_table(input_table = initial_table,
                                    spec = minispec)
p3_processed <- processed_table[processed_table$id == 3, ]
p3_processed %>% kbl()
```

The pre-processing mutates the initial table and (based on the specification) takes the earliest admission date for each stay (comprising a single or multiple episodes) and the latest discharge date. So now patient 3 still has 4 stays in the data, but now all episodes within the stay with `CIS_MARKER` 26, has the same admission and discharge date. This allows filtering to account for a whole stay rather than an episode within a stay.

## 3. Without and With preprocessing

Here are two full specification files, one without the preprocessing request, and one with.

```{r}
spec_without_preprocessing <- eider_example("spec_smr04.json")
writeLines(readLines(spec_without_preprocessing))
```
This spec is requesting a count of the number of times episode 1, 2, or 3 from `episode_within_cis` occurs for `DISCHARGE_DATE` earlier than (or equal to) 22nd April 2015.

For patient 3, without the preprocessing step we expect this to count 2 of the 8 episodes, the two with `CIS_MARKER` 26 and `DISCHARGE_DATE` of 22nd April 2015, the final episode in that stay does not satisfy the date condition and so is not expected to be counted.

```{r}
spec_with_preprocessing <- eider_example("spec_smr04_preprocessing.json")
writeLines(readLines(spec_with_preprocessing))
```

This spec is requesting the same thing, but now has the preprocessing step included. The `DISCHARGE_DATE` for all episodes in the stay with `CIS_MARKER` 26 will now all be the same - the latest discharge date from the stay, and the transform will count none of the total episodes for patient 3. This means that there will now be zero episodes which match the criteria.

Read in the data table
```{r}
smr04_table <- read_data(list(smr04 = eider_example("random_smr04_data.csv")))
```

This featurise call does not use the preprocessing flags
```{r}
w_out_preprocessing <- featurise(
  smr04_table,
  json_to_feature(spec_without_preprocessing)
)
```

This featurise call does use the preprocessing flags,
```{r}
w_preprocessing <- featurise(
  smr04_table,
  json_to_feature(spec_with_preprocessing)
)
```

Joining the resultant tables:
```{r}
joined_feature_table <- join_feature_tables(list(w_out_preprocessing,
                                                 w_preprocessing))
joined_feature_table %>% kbl()
```

Comparing the above, we can see that for patient with id 3, when no pre-processing is applied, two episodes are counted, but when the preprocessing step is applied, zero are.

[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "minisparra",
    "section": "",
    "text": "This Quarto book serves as a demo of the minisparra package (for which we still don’t have a real name).\nFirst, we load the package from the local directory.\ninstall.packages(\"../minisparra/\", repos = NULL, type = \"source\")\n\nInstalling package into '/home/runner/work/_temp/Library'\n(as 'lib' is unspecified)\n\nlibrary(miniSPARRA01)\nAlso, let’s set up a function to visualise tables nicely.\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(magrittr)\nkbl &lt;- function(x) {\n  x %&gt;%\n    knitr::kable(format = 'html', table.attr = 'data-quarto-disable-processing=\"true\"') %&gt;%\n    kableExtra::kable_styling(bootstrap_options = \"striped\", full_width = FALSE)\n}"
  },
  {
    "objectID": "index.html#read-in-data",
    "href": "index.html#read-in-data",
    "title": "minisparra",
    "section": "(1) Read in data",
    "text": "(1) Read in data\nWe begin by reading in all tables. Right now there’s only one.\nThis step must be done before any feature extraction to avoid having to read the same table multiple times.\n\nfilenames &lt;- c(\"../minisparra/tests/data/ae2.csv\")\nall_tables &lt;- read_all_tables(filenames)\n\nnames(all_tables)\n\n[1] \"../minisparra/tests/data/ae2.csv\"\n\n\nall_tables is a list which associates each of the filenames with the data read from that file.\n\nall_tables$`../minisparra/tests/data/ae2.csv` %&gt;% kbl()\n\n\n \n  \n    id \n    time \n    attendance_category \n    source_table \n    diagnosis_1 \n    diagnosis_2 \n    diagnosis_3 \n  \n \n\n  \n    1 \n    2016-03-17 \n    1 \n    AE2 \n    101 \n    NA \n    NA \n  \n  \n    1 \n    2016-03-18 \n    1 \n    AE2 \n    101 \n    102 \n    NA \n  \n  \n    1 \n    2016-03-19 \n    1 \n    AE2 \n    101 \n    103 \n    NA \n  \n  \n    1 \n    2016-03-20 \n    1 \n    AE2 \n    102 \n    101 \n    NA \n  \n  \n    2 \n    2016-03-21 \n    1 \n    AE2 \n    102 \n    NA \n    NA"
  },
  {
    "objectID": "index.html#defining-filters",
    "href": "index.html#defining-filters",
    "title": "minisparra",
    "section": "(2) Defining filters",
    "text": "(2) Defining filters\nNow we can start extracting features. The most complicated part of the feature is to decide how to filter the rows of the data tables, so we discuss this first.\nWe can have a ‘basic’ feature, which comprises an operator, a column name, and a vector of values. The operator can be in, lt, gt, …\n\ndiag_1 &lt;- list(\n  column = \"diagnosis_1\",\n  type = \"IN\",\n  value = c(101)\n)\n\nThe filter object above selects for any row where the value in the diagnosis_1 column is 101.\nLikewise we can have the following, which does the same for the diagnosis_2 and diagnosis_3 columns.\n\ndiag_2 &lt;- list(\n  column = \"diagnosis_2\",\n  type = \"IN\",\n  value = c(101)\n)\ndiag_3 &lt;- list(\n  column = \"diagnosis_3\",\n  type = \"IN\",\n  value = c(101)\n)\n\nBasic filters can be combined using filters with type or, and, or not. For example, the following selects for any rows where 1 appears in any of the three diagnosis columns:\n\ndiag_1_or_2_or_3 &lt;- list(\n  type = \"OR\",\n  subfilters = list(diag_1, diag_2, diag_3)\n)\n\nWe’ll wrap this in a function for later reuse.\n\nmake_filter &lt;- function(diagnosis_value) {\n  diag_1 &lt;- list(\n    column = \"diagnosis_1\",\n    type = \"IN\",\n    value = c(diagnosis_value)\n  )\n  diag_2 &lt;- list(\n    column = \"diagnosis_2\",\n    type = \"IN\",\n    value = c(diagnosis_value)\n  )\n  diag_3 &lt;- list(\n    column = \"diagnosis_3\",\n    type = \"IN\",\n    value = c(diagnosis_value)\n  )\n  list(\n    type = \"OR\",\n    subfilters = list(diag_1, diag_2, diag_3)\n  )\n}"
  },
  {
    "objectID": "index.html#b-reading-in-filters-from-json",
    "href": "index.html#b-reading-in-filters-from-json",
    "title": "minisparra",
    "section": "(2b) Reading in filters from JSON",
    "text": "(2b) Reading in filters from JSON\nFilters (technically entire feature definitions; but the filter is the most complicated part of that) can also be read in from JSON files:\n\nwriteLines(readLines(\"example_101.json\"))\n\n{\n  \"source_file\": \"ae2.csv\",\n  \"transformation_type\": \"count\",\n  \"primary_filter\": {\n    \"type\": [\"OR\"],\n    \"subfilters\": {\n      \"subfilter_21\": {\n        \"column\": \"diagnosis_1\",\n        \"type\": \"IN\",\n        \"value\": [101]\n      },\n      \"subfilter_22\": {\n        \"column\": \"diagnosis_2\",\n        \"type\": \"IN\",\n        \"value\": [101]\n      },\n      \"subfilter_23\": {\n        \"column\": \"diagnosis_3\",\n        \"type\": \"IN\",\n        \"value\": [101]\n      }\n    }\n  }\n}\n\n\nThis gets parsed to the following:\n\njson_feature &lt;- json_to_feature(\"example_101.json\")\n\n[1] \"Parsing nested filter\"\n[1] \"Parsing single filter\"\n[1] \"Parsing single filter\"\n[1] \"Parsing single filter\"\n\njson_feature$primary_filter\n\n$type\n[1] \"OR\"\n\n$subfilters\n$subfilters[[1]]\n$subfilters[[1]]$column\n[1] \"diagnosis_1\"\n\n$subfilters[[1]]$type\n[1] \"IN\"\n\n$subfilters[[1]]$value\n[1] 101\n\n\n$subfilters[[2]]\n$subfilters[[2]]$column\n[1] \"diagnosis_2\"\n\n$subfilters[[2]]$type\n[1] \"IN\"\n\n$subfilters[[2]]$value\n[1] 101\n\n\n$subfilters[[3]]\n$subfilters[[3]]$column\n[1] \"diagnosis_3\"\n\n$subfilters[[3]]$type\n[1] \"IN\"\n\n$subfilters[[3]]$value\n[1] 101\n\n\nand we can compare it to the filter we defined earlier. The only difference is that the JSON feature has integer data types, while the R feature has double data types, which has no downstream effect.\n\nlibrary(waldo)\ncompare(json_feature$primary_filter, make_filter(101))\n\n`old$subfilters[[1]]$value` is an integer vector (101)\n`new$subfilters[[1]]$value` is a double vector (101)\n\n`old$subfilters[[2]]$value` is an integer vector (101)\n`new$subfilters[[2]]$value` is a double vector (101)\n\n`old$subfilters[[3]]$value` is an integer vector (101)\n`new$subfilters[[3]]$value` is a double vector (101)"
  },
  {
    "objectID": "index.html#extracting-features",
    "href": "index.html#extracting-features",
    "title": "minisparra",
    "section": "(3) Extracting features",
    "text": "(3) Extracting features\nFor reference, here’s the original data table again.\n\nall_tables$`../minisparra/tests/data/ae2.csv` %&gt;% kbl()\n\n\n \n  \n    id \n    time \n    attendance_category \n    source_table \n    diagnosis_1 \n    diagnosis_2 \n    diagnosis_3 \n  \n \n\n  \n    1 \n    2016-03-17 \n    1 \n    AE2 \n    101 \n    NA \n    NA \n  \n  \n    1 \n    2016-03-18 \n    1 \n    AE2 \n    101 \n    102 \n    NA \n  \n  \n    1 \n    2016-03-19 \n    1 \n    AE2 \n    101 \n    103 \n    NA \n  \n  \n    1 \n    2016-03-20 \n    1 \n    AE2 \n    102 \n    101 \n    NA \n  \n  \n    2 \n    2016-03-21 \n    1 \n    AE2 \n    102 \n    NA \n    NA \n  \n\n\n\n\n\nWe can now use this filter to extract a feature from the data table. Note that we must provide a ‘missing value’ to be used for patients with no data in the table, for example, patient 2.\n\ndiag_101_count &lt;- featurise_count(\n  all_tables = all_tables,\n  source_table_file = \"../minisparra/tests/data/ae2.csv\",\n  filter_obj = diag_1_or_2_or_3,\n  output_column_name = \"diag_101\",\n  missing_value = 0\n)\n\nnames(diag_101_count)\n\n[1] \"feature_table\" \"missing_value\"\n\n\ndiag_101_count$feature_table is the data frame with the feature values for each patient ID. Since all rows with patient 2 were removed during the filtering step, diag_101_count must also carry the missing value forward to the next step.\n\ndiag_101_count$feature_table %&gt;% kbl()\n\n\n \n  \n    id \n    diag_101 \n  \n \n\n  \n    1 \n    4"
  },
  {
    "objectID": "index.html#joining-features",
    "href": "index.html#joining-features",
    "title": "minisparra",
    "section": "(4) Joining features",
    "text": "(4) Joining features\nFor an example, let’s generate the same features but for diagnoses of 102 and 103 respectively.\n\ndiag_102_count &lt;- featurise_count(\n  all_tables = all_tables,\n  source_table_file = \"../minisparra/tests/data/ae2.csv\",\n  filter_obj = make_filter(102),\n  output_column_name = \"diag_102\",\n  missing_value = 0\n)\n\ndiag_103_count &lt;- featurise_count(\n  all_tables = all_tables,\n  source_table_file = \"../minisparra/tests/data/ae2.csv\",\n  filter_obj = make_filter(103),\n  output_column_name = \"diag_103\",\n  missing_value = 1000   # For demonstration purposes\n)\n\nLet’s see what these feature tables look like:\n\ndiag_102_count$feature_table %&gt;% kbl()\n\n\n \n  \n    id \n    diag_102 \n  \n \n\n  \n    1 \n    2 \n  \n  \n    2 \n    1 \n  \n\n\n\n\n\n\ndiag_103_count$feature_table %&gt;% kbl()\n\n\n \n  \n    id \n    diag_103 \n  \n \n\n  \n    1 \n    1 \n  \n\n\n\n\n\nWhen we join them together, notice that the respective missing values for patient 2 are inserted into the final feature table.\n\njoin_feature_tables(list(diag_101_count, diag_102_count, diag_103_count)) %&gt;% kbl()\n\n\n \n  \n    id \n    diag_101 \n    diag_102 \n    diag_103 \n  \n \n\n  \n    1 \n    4 \n    2 \n    1 \n  \n  \n    2 \n    0 \n    1 \n    1000"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]